## 第II部 初級編（partIV)  
第13章 日付と日時（基礎編）, 第14章 SQLのエラー
---
<br>

### ● 第13章 日付と日時（基礎編）
---

なお、日付と日時については、あくまでPostgreSQLのみに通用するとのこと。  
こちらについては、製品ごとにバラバラの仕様らしい。  

<br>

#### 13.1 日付型
---

日付の書き方は下記のとおり。  

```sql
-- 第１の書き方
select '2019-09-22'::date;
-- 第２の書き方
select '2019-9-1'::date;
-- 第３の書き方
select make_date(2019, 9, 22);

   date    
------------
 2019-09-22
(1 row)
```

なお、特定の日付から別の日付を引くと、日数になる。  

```sql
-- ２日間の間隔があると、２が返ってくる
select '2020-09-22'::date - '2020-09-20'::date;

 ?column? 
----------
        2
(1 row)
```

また、日数を足すと、日付が得られる。  

```sql
-- ２を足すと、2日後の日付になる
select '2020-09-22'::date + 2;

  ?column?  
------------
 2020-09-24
(1 row)
```

<br>

#### 13.2 タイムスタンプ型
---

日時も作成できる。  

```sql
-- 第一の書き方
select '2019-09-22 11:00:00'::timestamp;
-- 第２の書き方
select make_timestamp(2019, 9, 22, 11, 0, 0);

timestamp      
---------------------
 2019-09-22 11:00:00
(1 row)
```

日付と日時の変換もできる。  

```sql
select ('2019-09-22'::date)::timestamp;

timestamp      
---------------------
 2019-09-22 00:00:00
(1 row)
```

```sql
select ('2019-09-22 23:59:59'::timestamp)::date;

    date    
------------
 2019-09-22
(1 row)
```

<br>

#### 13.3 インターバル型
---

インターバル型 (interval type) とは、時間を表すデータ型です。  
期間を表すものであって、その時点の時刻を表すものではないので要注意。  

```sql
select '2019-09-22 17:00:00'::timestamp
     - '2019-09-22 11:00:00'::timestamp;

 ?column? 
----------
 06:00:00
(1 row)
```

日付であってもタイムスタンプ型に変換すれば、インターバル型で値を得ることができる。  
インターバル型には、書き方がいくつかある。  

```sql
select '2020-05-05'::timestamp
     - '2020-05-02'::timestamp
     + '1 day'::interval;

 ?column? 
----------
 4 days
(1 row)
```

インターバル型は、「日数」だけでなく「週数」や「月数」を表せるのが便利。
- 「’n days’::interval」でn日間
- 「’n weeks’::interval」でn週間
- 「’n months’::interval」でnヶ月間

<br>

#### 13.4 今日の日付を求める
---

```sql
select current_date;
select 'today'::date;
```



<br>

#### 13.5 昨日や明日の日付を求める
---

今日の日付の出し方の応用。  
current_dateに数字を足し引きする。  
もしくは、yesterdayやtomorrowを使う。  

```sql
select current_date + 1;
select 'yesterday'::date;
select 'tomorrow'::date;
```

<br>

#### 13.6 現在の日時を求める
---

```sql
select current_timestamp;
select now();
select 'now'::timestamp;
```

<br>

#### 13.7 日付から年や月や日を求める
---

date_part()関数を使う。
他、select extract(year from '2019-09-22'::date)もある。

```sql
select date_part('year' , '2019-09-22'::date) as year
     , date_part('month', '2019-09-22'::date) as month
     , date_part('day' , '2019-09-22'::date) as day;
```

<br>

#### 13.8 日数や期間を計算する
---

date型やtimestamp型があるが、揃えて使うこと。  
求めている型に合わせて計算してもいいし、計算した後に合わせてもよい。  


<br>

#### 13.9 誕生日から年齢を計算する
---

age()関数を使い、結果から年だけを取り出す。  
誕生日と今日の日付の差（つまり年齢）も表示する。  

自らの誕生日を入力。  
正確な年齢が返ってきて、厳しい現実を突きつけられた。  

```sql

select age(current_date, '1988-09-01'::date);

           age           
-------------------------
 31 years 8 mons 18 days
(1 row)

```

<br>

### ● 第14章 SQLのエラー
---

SQLを実行して遭遇する、ありがちなエラーを学習する。


<br>

#### 14.1 「==」が使えない
---

rubyでは == を使うが、sqlでは = を使う

<br>

#### 14.2 「=」を使っているのにエラー
---

型を揃えること。  

以下のような形でエラーメッセージが出る。  
（dateとintegerの一致を確かめようとしている場合）  

```
ERROR: operator does not exist: date = integer
```

<br>

#### 14.3 in演算子の右側に値がない
---

in演算子の右側（括弧内）に値が何もないとエラー  

in演算子は、「select A in (B);」という形の場合は、  
BにAがあるか判断するので、Bが空であると当然エラーになる。  

<br>

#### 14.4 select文が何の結果も表示しない
---

select 句に列名や「*」をうっかり指定し忘れると  
(select 句に何も指定しないと)、実行結果が何も表示されない。  

<br>

#### 14.5 グループ化のキーではない列名を使う
---

男女別に最高身長の人とその名前を出したい。  
意図は分かるが、以下は誤り。  

```sql
-- gender以外をselectするとエラー

select gender, max(height), name
from members
group by gender;
```

エラーの解決方法は、男女別に身長の最大値を検索する部分と、  
身長の最大値をもつメンバーを検索する部分を、別々の select 文に  
したあとで、それらを組み合わせること。

```sql

select m1.*
from members m1
  -- 男女別の最高身長を示すテーブルをjoinする
  join (select gender, max(height) as max_height
        from members group by gender) as m2
    -- 性別と最高身長が一致することを条件とする
    on m1.gender = m2.gender
      and m1.height = m2.max_height
order by gender desc; 
```

<br>

#### 14.6 列の別名をwhere句で参照する
---

select句で別名をつけた場合、where句やhaving句で使うとエラーになる。  

<br>

#### 14.7 insert 文で列の数やデータ型が一致しない
---

挿入先の列は3つなのに、4つのデータを挿入しようとするとエラーになる。  
求められている型に一致しないデータを挿入しようとするとエラーになる。  

<br>

#### 14.8 coalesce() で引数のデータ型が一致しない
---

coalesce() 関数は nullでなければ括弧内の左の値、nullであれば右の値を採用する。  
左と右のデータ型が一致していないと、エラーになる。  

<br>

#### 14.9 サブクエリが複数行を返す
---

サブクエリにおいて、単一の値を求められている状況にもかかわらず複数行の回答を返す  
サブクエリを入力するとエラーになる。  

<br>

#### 14.10 from句のサブクエリをwhere句で参照
---

from句にサブクエリを使っている場合、それをwhere句で参照しようとするとエラーになる。  
with句を使ってサブクエリの結果を一時テーブルとして使うとよい。  

<br>

#### 14.11 select 句のサブクエリが複数の値を返した
---

select 句に埋め込んだサブクエリの実行結果が、複数列だったり複数行だったりするとエラーになる。  

<br>

#### 14.12 テーブルや列の名前がキーワードと同じ
---

キーワードと同じ名前のテーブルや列を作ると、エラーになります。  
なお、キーワードとは、SQLで特別な役割が与えられた単語のことを指す。  

<br>

#### 14.13 再帰クエリでrecursiveオプション忘れ
---

再帰クエリ で「recursive」オプションを忘れると、エラーになる。

<br>

#### 14.14 トランザクション中でエラー
---

トランザクション中のエラーが起きると、その性質上、  
ロールバックされ、全ての処理がエラーとなる。  
（そもそも一部の処理だけ行ってしまうと困るため、そのように設定している）  

<br>

#### 14.15 トランザクション中でインデックス作成
---

トランザクション中である場合、「concurrently」オプションをつけて  
バックグラウンドでインデックスを作成しようとすると、エラーになる。  

