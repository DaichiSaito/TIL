## 第II部 初級編（partIII)  
第10章 制約、主キー、外部キー, 第11章 テーブルの関連, 第12章 インデックス
---
<br>

### ● 第10章 制約、主キー、外部キー
---

<br>

#### NOTNULL制約
---

列に null が入るのを禁止する制約を指す。  
NOTNULL制約がついているか調べるには、psqlコマンドで「\dt テーブル名」  

```sql
create table movies (
  movie_id  integer   primary key
  -- 「not null」がNOTNULL制約
, title     text      not null unique
);
```

<br>

#### 一意制約
---

列の値に重複があってはならない制約を指す。  
一意制約がついているか調べるには、psqlで「\d テーブル名」  

```sql
create table movies (
  movie_id  integer   primary key
  -- 「unique」が一意制約
, title     text      not null unique
);
```

<br>

#### 主キーと主キー制約
---

主キー (Primary key)とは、テーブル内の行を特定するための列。  
主キーがどれかを調べるには、psql コマンドで「\d テーブル名」  

主キーには特徴があり、  
- 値が一意でなければならない（特定できなくなるため）  
- 値がnullであってはならない（NULL制約）  
- 主キーの値は変わってはならない  

```sql
create table movies (
  -- 「primary key」が主キーを指定している
  movie_id   integer   primary key
, title      text      not null unique );
```

<br>

#### 外部キーと外部キー制約
---

外部キー (Foregin key) とは、他テーブルの主キーを参照している列。  
外部キーを調べるには、psqlコマンドで「\d テーブル名」  

外部キー制約 (Foreign key constraint)とは、参照先のテーブルにない値が外部キーに入るのを禁止する制約。  
他から参照されている主キーを変更しようとすると、エラーになる。  

```sql
create table characters (
  id         integer   primary key
  -- 「references movies(movie_id)」が外部キーを指定している
, movie_id   integer   references movies(movie_id)
, name       text      not null
, gender     char(1)   not null
);

```

<br>

#### 複合主キーと複合外部キー
---

複数の列から構成された主キーは複合主キー (Composite primary key) という。 
テーブルに対して主キーがどれかを指定する。

参照されている複数の外部キーは、複合外部キーという。  

```sql
create table writings (
  book_id    integer   not null references books(id)
, author_id  integer   not null references authors(id)
-- 「primary key(book_id, author_id)」が主キーを複数指定している

, primary key(book_id, author_id)
);
```

<br>

#### 練習問題
---

##### NOT NULL 制約 

- NULLにできないカラム（列）
- 必ず値が入っていないといけない場合に使う

##### 一意制約

- 他の行のデータと値が重複してはいけない
- 他のデータと必ず区別させたい時に使う

##### 主キー

- 行を特定するための列
- 条件があり、① not null ② 一意 ③ 値が変わらないこと

##### 外部キー

- 外部キーとは、他のテーブルの主キーを参照するための列
- 外部キーには参照先にある値しか入れることができない（紐付けできない）
- 外部キーが参照している値は変更できない

<br>

### ● 第11章 テーブルの関連
---

関連 (Relationship) とはテーブル間の関連を指す。  
関連には種類があり、代表的なのが「1対多」と「多対多」。  

「1対多」の事例  
- セ・パリーグと所属球団の関係
- 各都道府県と市町村の関係

<br>

「多対多」の事例
- 大学の生徒と受けている授業の関係
  - 各生徒は多数の授業を受けている
  - 各授業を受けている生徒は大勢いる
  - 双方向に１対多なので、多対多となる

<br>

#### 1対多
---

1対多の関係では、「多」の側のテーブルから「1」の側のテーブルを参照。  
セリーグと所属球団の関係で考える。  

巨人・中日・阪神・広島・ヤクルト・横浜に外部キーを作成。  
セリーグの方にある主キーを参照するようにする。  

逆にしてしまうと、セリーグの方に６つの球団IDを保持しなければならず不都合。  



```sql
-- ジブリ映画とキャラクターの事例
-- ここでは、ジブリ映画が「１」であり、キャラが「多」となる
-- 紛らわしいので、要注意

select m.*, c.*
from movies m
join characters c on m.movie_id = c.movie_id
order by m.movie_id, c.id;

 movie_id |      title       | id  | movie_id |   name   | gender 
----------+------------------+-----+----------+----------+--------
       93 | 風の谷のナウシカ | 401 |       93 | ナウシカ | F
       94 | 天空の城ラピュタ | 402 |       94 | パズー   | M
       94 | 天空の城ラピュタ | 403 |       94 | シータ   | F
       94 | 天空の城ラピュタ | 404 |       94 | ムスカ   | M
       95 | となりのトトロ   | 405 |       95 | さつき   | F
       95 | となりのトトロ   | 406 |       95 | メイ     | F
(6 rows)

```
なお、上記の表のとおり、「1対多」の場合はツリー構造で表される。  
つまり、風の谷の〜 → ナウシカ、ラピュタ → パズー・シータ・ムスカ、トトロ → さつき・メイ  
以上のように、上部のカテゴリーがあって、そこから枝分かれする。

<br>

#### 多対多

---

関係を表す「交差テーブル」というものを作成し、紐付けを行う。  
以下のように授業を受けていると仮定する。  

たろう → 英語、数学
はなこ → 数学、物理、化学
ジョン → 日本語、化学

ここで、関係を表す交差テーブルを作成する。  
以下の二つのテーブルから関係性を表す「交差テーブル」を作成する。  

```sql
-- 生徒のテーブル
student_id |  name
-----------+---------
         1 | taro
         2 | hanako
         3 | john
```

```sql
-- 授業のテーブル
class_id |  name
---------+---------
      11 | Japanese
      12 | English
      13 | Math
      14 | Physics
      15 | Chemistry
```

```sql
-- 交差テーブル SC
-- 交差テーブルを使うことで、１つのフィールドに複数の値を保管する必要がなくなる
student_id | class_id
-----------+---------
         1 | 12
         1 | 13
         2 | 13
         2 | 14
         2 | 15
         3 | 11
         3 | 15
```

ここで交差テーブルを作る場合、以下のとおりコードを書く

```sql
create table SC ( 
  student_id integer references classes(id) ← 外部キー
, class_id   integer references students(id) ← 外部キー
, primary key(student_id, class_id) ← 複合主キー
);
```

<br>

#### ER図

---

ERD = Entity-Relationship Diagram
テーブルとその関連を表した図を指す。  

[やさしい図解で学ぶ ER図 表記法一覧 \- Qiita](https://qiita.com/ramuneru/items/32fbf3032b625f71b69d)  

極めていくと奥深いらしい。。。  
Cacooなど、フリーでER図を作れるサービスがあるので、今後活用していきたい。  

<br>

#### 練習問題

---

苦戦するが、何とか終了。  

更なる練習が必要だと感じたが、とりあえず主キーと外部キーを紐付けて、  
joinするということは、何となく理解できた。  

<br>

### ● 第12章 インデックス
---

インデックス = 索引  
つまり、検索に必要な情報だけを抜き出したデータ。  

インデックスがない場合、Sequential Scan を行う。  
（順を追って、全てのデータを最後まで読み込む。）  

インデックスがある場合、索引データだけを読み込む。  
よって、検索が高速。  

<br>

#### インデックスの作成と削除

---

インデックスは、下記のとおり作成する。  
複数列を指定し、複数インデックスを作成することができる。  

```sql
create index インデックス名 on テーブル名 (列名, 列名, ...)
```

インデックスを削除するには、下記のとおり。  

```sql
drop index インデックス名
```

ダミーデータを 100 万行

データが100 万行ある場合、検索時間は0.12秒。  
インデックスが作成された場合、検索時間は0.0007秒。  
約170倍高速化される。  

なお、explain を最初に使ってSQLを書くと、  
SQLの動作が分かるため、インデックスを使っているかも確認できる。  

<br>

#### カーディナリティ

---

Cardinality = 列に入っている値の種類の多さ  

例えば、氏名のカラムがある場合、氏名は重複があることが少ないので、
そのカラムは「カーディナリティが高い」という。  

他方、性別はMかFに分かれてしまい、値が２つだけに絞られてしまうため、
このカラムは「カーディナリティが低い」という。  

インデックスの効果は、当然カーディナリティが高い方が得やすい。  
カーディナリティが低いと、検索をしても、十分に絞り込みの効果が得られない。  

なお、この効果を意識して、主キーや一意制約（primary keys + unique)のカラムには、  
自動的にインデックスが作成されるようになっている。  

ただし、インデックスの効果が得にくい場合や、関数・演算子を使っている場合、  
データ型が一致していない場合は、インデックスが使わない。  

<br>

#### 複合インデックス

---

複合インデックスとは、複数のインデックスを指定すること。  
以下の場合、最初の列であるdateが指定されていないと、インデックスは使われない。

```sql

create table pocketbook(
  id      serial    primary key
, date    date      not null default current_date
, amount  integer   not null
, memo    text
);

-- where 句を活用して、date, amountを指定したSQLを走らせる場合、インデックスが使われる
-- dateだけの指定でも使われるが、amountだけの指定では使われない
create index pocketbook_date_amount_idx
  on pocketbook(date, amount);

```

<br>

#### インデックスの注意点

---

- 行の挿入や変更が遅くなる。
  - 具体的には、insert, update, deleteなど。  
  - データ本体だけでなく、インデックスの更新も必要になるため。  

- また、大量データ挿入時はインデックスを外す。  
- インデックスの作成はテーブルのロックがされてしまうため、ロックを回避することも検討する。  


<br>

#### 補足事項
---

式インデックスの活用
  - インデックスでは関数や演算子は使えないので、式を使った式インデックスを使う

部分インデックス
  - 値に大きな偏りがある場合、数が少ない法の値を検索するためのインデックスを作成するのは有効

インデックスオンリースキャン
  - テーブルから行を読み込むことなく、インデックスのみ読み込むこと
  - インデックスだけしか読まないので、動作が高速