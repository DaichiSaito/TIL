# Chapter04 配列や繰り返しを処理する

## 配列

### 配列の概要

- []で表される
- 要素にはindexがある
  - 0からスタートする
- lengthもしくはsizeメソッドで要素数を取得できる
  - 繰り返し処理をする場合によく使うイメージ

```rb
a = [ 10, 20, 30 ]

# 0番目の要素を取得（0からスタート）
a[0] #=> 10

a.length #=> 3
```

### 要素の変更、追加、削除

要素は変更できる。  

```rb
a =[ 10, 20, 30]

a[1] = 77
a #=> [ 77, 20, 30 ]
```

要素は追加できる。  
間がある場合、`nil`で埋められる。  

```rb
a =[ 10, 20, 30]

a[5] = 77
a #=> [ 10, 20, 30, nil, 77 ]
```

配列の最後に要素を追加したい場合、以下のとおり書くことができる。  

```rb
a = [ 10, 20, 30 ]

a << 77
a #=> [ 10, 20, 30 ,77 ]
```

配列内の特定の位置にある要素を削除したい場合、delete_atメソッドを使う。  

```rb
a = [ 10, 20, 30 ]

# ２番目の要素を削除し、戻り値が削除した要素になる
a.delete_at(1) #=> 20
a #=> [ 10,30 ]

# 存在しない添え字を指定するとnilになる
a.delete_at(100) #=> nil
```

### 配列を使った多重代入

配列を使った多重代入について。  

```rb
a, b = [ 1, 2 ]
a #=> 1
b #=> 2

c, d = [10]
c #=> 10
d #=> nil

e = [ 100, 200 ]
e #=> 100
```

## ブロック

### Rubyの繰り返し処理

Rubyでは`for`を使うことが少ない。  
`each`を配列自体に使うことが多い。  

`each`メソッドにより、配列の要素を最初から最後まで取り出している。  

```rb
numbers = [ 1, 2, 3, 4 ]
sum = 0
numbers.each do |n|
  sum += n
end #=> 10
```

```rb
numbers = [ 1, 2, 3, 4 ]
sum = 0
numbers.each { |n| sum += n } #=> 10
```

以上の例においては、それぞれの要素が足し上げられて、  
`sum`という変数に代入されている。  

この操作を定義しているのが、ブロックに関する部分である。  
ブロックの範囲とは、`do |n|` 以降の部分である。  

ブロックの内部（つまり、`sum += n`に関する部分）では、  
自由にRubyのコードが書けます。  

### 配列の要素を削除する条件を指定する

ブロックを使うと、配列の中の奇数だけを削除することもできる。  

```rb
a =[ 1, 2, 3 ]
a.delete_if do |n|
  n.odd?
end
a #=> [2]
```

### 注意点

- ブロック内部の変数のスコープは、あくまでブロック内
- ブロック引数（多くの場合、|n|）について
  - ブロック内部で使わない場合、省略できる
  - ブロック内部
- do ...endは、{} で書き換えられる
  - 先ほどの事例は以下のとおり書き換え可能

```rb
a =[ 1, 2, 3 ]
a.delete_if { |n| n.odd? }
```

## ブロックを使う配列のメソッド

### map/collect

mapメソッドは、各要素に対してブロックを評価した結果を「新しい配列」にして返す。  
新しい配列を宣言しなくとも、戻り値を利用して以下のように書ける。  

```rb
# eachメソッド

numbers = [ 1, 2, 3, 4, 5 ]
new_numbers = []
# n * 10 の処理を行い、new_numbers配列に格納していく
numbers.each { |n| new_numbers << n * 10 }
new_numbers #=> [10, 20, 30, 40 ,50]
```

```rb
# mapメソッドによるリファクタリング

numbers = [ 1, 2, 3, 4, 5 ]
# new_numbersを宣言し、そこに戻り値として生成された配列を格納する
new_numbers = numbers.map {|n| n *10 }
new_numbers  #=> [10, 20, 30, 40 ,50]
```

### select/find_all/reject

selectメソッド（エイリアスメソッドはfind_all)は各要素に対してブロックを評価し、  
「その戻り値が真の要素を集めた配列を返す」メソッドである。  

```rb
numbers = [ 1, 2, 3, 4, 5 ]
new_numbers = numbers.select {|n| n.even? }
new_numbers  #=> [2, 4]
```

rejectメソッドを使うと、真ではなく、その戻り値が「偽」の要素を集めた配列を返す。  

```rb
numbers = [ 1, 2, 3, 4, 5 ]
new_numbers = numbers.reject {|n| n.even? }
new_numbers  #=> [ 1, 3, 5 ]
```

### find/detectメソッド

ブロックの戻り値が真になった最初の要素を返す。  
配列ではないことに注意。

```rb
numbers = [ 1, 2, 3, 4, 5 ]
new_numbers = numbers.find {|n| n.even? }
new_numbers  #=> 2
```

### inject/reduceメソッド

たたみ込み演算を行うメソッドです。  

```rb
numbers = [ 1, 2, 3, 4 ]
sum = numbers.inject(0) {|result, n| result + n }
sum  #=> 10
```

ここで何が起きているのかというと以下のとおり。  

```
result = 0, n = 1
result + n = 1 # これをたたみ込む

result = 1 , n = 2
result + n = 3 # これをたたみ込む

result = 3, n = 3
result + n = 6 # これをたたみ込む

result = 6, n = 4
result + n = 10 # これをたたみ込む
```

### & と シンボルを使って簡潔に書く

ブロックを使うメソッドは条件によって簡潔に書くことができる。  

```rb
# 書き換え前
[ 1, 2, 3, 4, 5 ].select { |n| n.odd? } #=> [ 1, 3, 5 ]

# 書き換え後
# ここでは &:odd?という引数を渡している
[ 1, 2, 3, 4, 5 ].select (&:odd?) #=> [ 1, 3, 5 ]
```

使える条件は以下のとおり。

1. ブロック引数が１個だけ
2. ブロックの中で呼び出すメソッドには引数がない
3. ブロックの中では、ブロック引数に対してメソッドを呼び出す以外の処理がない

## 範囲

値の範囲を示すオブジェクトがある。  
これらはRangeクラスに属している。  

```rb
1..5
1...5
'a'..'e'
```

`include?`メソッドを使うと、引数の値に含まれるか判定できる。  

```rb
range = 1..5
range.include?(3) #=> true
range.include?(4.9) #=> true
range.include?(5) #=> true
```

なお、`..`と`...`には違いがある。  
`...`だと末尾が含まれない。

```rb
range = 1...5
range.include?(5) #=> false
```

### 配列や文字列の一部を抜き出す

```rb
a = [ 1, 2, 3, 4, 5]

# １〜３番目の要素を取得
a[1..3] = [ 2, 3, 4 ]
```

### 値が連続する配列を作成

`to_a`メソッドを使って、配列に変換する。

```rb
(1..5)to_a = [ 1, 2, 3, 4, 5 ]
```

splat展開という書き方もある。  

```rb
[*1..5] #=> [ 1, 2, 3, 4, 5 ]
```

### 繰り返し処理を行う

範囲オブジェクトに対して、直接`each`メソッドを呼び出すことができる。  

```rb
sum = 0
sum = (1..4).each { |n| sum += n }
sum #=> 10
```

stepメソッドを使うと、値を増やす間隔を指定できる。  

```rb
numbers = []
# 1から10まで2つ飛ばしで繰り返し処理を行う
(1..10).step(2) { |n| numbers << n}
numbers #=> [ 1, 3, 5, 7, 9 ]
```

## 例題：RGB変換プログラムを作成する

`rgb_test.rb`と`rgb.rb`を作成し、実践してみた。  
リファクタリング後のコードがヤバイ。。。  

## 配列についてもっと詳しく

### さまざまな要素の取得方法

添え字を２つ使うと、添え字の位置と取得する長さを指定できる。  
この場合、配列が返ってくる。  

```rb
# a の１番目（つまり２番目）の要素から、要素を3つ取得する

a = [1, 2, 3, 4, 5]
a[1, 3] #=> [2, 3, 4]
```

values_atメソッドを使うと、取得したい要素を指定できる。  

```rb
# a の０番目、２番目、４番目の要素を取得する

a = [1, 2, 3, 4, 5]
a.values_at(0, 2, 4) #=> [1, 3, 5]
```

「配列の長さ - 1 」を指定すれば、最後の要素を取得できる。  
単純に「-1」と書いてもよいし、lastメソッドを使ってもよい。  

```rb
# a の最後の要素を取得する

# こうやって当然書ける
a = [1, 2, 3, 4, 5]
a[a.length - 1] #=> 5

# 楽に書ける
a[-1] #=> 5

# 最後から２番目の要素を取得
a[-2] #=> 4

# lastメソッドを使ってもよい
a.last #=> 5

# firstメソッドもある
a.first #=> 0
```

### さまざまな要素の変更方法

値を変更する場合、以下のとおり。

```rb
a = [1, 2, 3]
a[0] = 100
a #=> [100, 2, 3]

a[-1] = 300
a #=> [100, 2 , 300]
```

開始位置と長さを指定して、要素を置き換えることもできる。  

```rb
a = [1, 2, 3, 4, 5]
# 2つ目から３要素分を100で置き換える
a[1, 3] = 100
a #=> [1, 100, 5]

# 2 ~ 4 が 100 に置き換わった
```

配列に要素を加えていく場合、<< を使うかと思うが、
`push`メソッドを使うこともできる。  

```rb
a = []
a.push(1) #=> [1]
a.push(2, 3) #=> [1, 2, 3]

b = []
b << 1 #=> [1]
b << [2, 3] #=> [1, [2, 3]]
# 複数の要素を一度に追加するのは無理？なので、flattenメソッドを使う
b.flatten #=> [1, 2, 3]
```

[Rubyで複数の配列を１つの配列に結合するために色々やってみた \- Qiita](https://qiita.com/na1412/items/65f883896c85011d6509)  

指定した値に一致する要素を削除したい場合、`delete`メソッドを使う。  

```rb
a = [1, 2, 3, 1, 2, 3]
a.delete(2) #=> 2
a #=> [1, 3, 1, 3]

# 存在しない値を削除しようとすると、戻り値はnilになる
a.delete(5) #=> nil
a #=> [1, 3, 1, 3]
```

### 配列の連結

2つの配列を連結したい場合は、concatメソッドか、`+` 演算子を使います。  
`concat`は元のオブジェクトを変更する破壊的メソッドであり、  
`+` 演算子は元のオブジェクトを変更しない非破壊的なメソッドである。  

```rb
# 破壊的

a = [1]
b = [2, 3]
a.concat(b) #=> [1, 2, 3]
a #=> [1, 2, 3]
b #=> [2, 3]
```

```rb
# 非破壊的

a = [1]
b = [2, 3]
a + b #=> [1, 2, 3]
a #=> [1]
```

### 配列の和集合、差集合、積集合

そもそも和集合・差集合・積集合って。。。

```rb
# 和集合だと重複を取り除いて、配列を足し上げてくれる
# bの中から、重複していない[2]のみを足し上げている

a = [1, 4, 3] 
b = [4, 3, 2]
a | b #=> [1, 4, 3, 2]
```

```rb
# 差集合だと重複している部分のみを差し引く
# 共通している要素である 4 と 3 を a から差し引く

a = [1, 4, 3]
b = [4, 3, 2]
a - b #=> [1]
```

```rb
# 積集合は、重複している部分を求めてくれる
# a, b の共通部分を取り出すイメージ
# ちなみに、集合演算をやる場合、Setクラスにするとよいらしい

a = [1, 4, 3]
b = [4, 3, 2]
a & b #=> [4, 3]
```
