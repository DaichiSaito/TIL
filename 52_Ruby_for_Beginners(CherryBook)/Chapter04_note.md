# Chapter04 配列や繰り返しを処理する

## 配列

### 配列の概要

- []で表される
- 要素にはindexがある
  - 0からスタートする
- lengthもしくはsizeメソッドで要素数を取得できる
  - 繰り返し処理をする場合によく使うイメージ

```rb
a = [ 10, 20, 30 ]

# 0番目の要素を取得（0からスタート）
a[0] #=> 10

a.length #=> 3
```

### 要素の変更、追加、削除

要素は変更できる。  

```rb
a =[ 10, 20, 30]

a[1] = 77
a #=> [ 77, 20, 30 ]
```

要素は追加できる。  
間がある場合、`nil`で埋められる。  

```rb
a =[ 10, 20, 30]

a[5] = 77
a #=> [ 10, 20, 30, nil, 77 ]
```

配列の最後に要素を追加したい場合、以下のとおり書くことができる。  

```rb
a = [ 10, 20, 30 ]

a << 77
a #=> [ 10, 20, 30 ,77 ]
```

配列内の特定の位置にある要素を削除したい場合、delete_atメソッドを使う。  

```rb
a = [ 10, 20, 30 ]

# ２番目の要素を削除し、戻り値が削除した要素になる
a.delete_at(1) #=> 20
a #=> [ 10,30 ]

# 存在しない添え字を指定するとnilになる
a.delete_at(100) #=> nil
```

### 配列を使った多重代入

配列を使った多重代入について。  

```rb
a, b = [ 1, 2 ]
a #=> 1
b #=> 2

c, d = [10]
c #=> 10
d #=> nil

e = [ 100, 200 ]
e #=> 100
```

## ブロック

### Rubyの繰り返し処理

Rubyでは`for`を使うことが少ない。  
`each`を配列自体に使うことが多い。  

`each`メソッドにより、配列の要素を最初から最後まで取り出している。  

```rb
numbers = [ 1, 2, 3, 4 ]
sum = 0
numbers.each do |n|
  sum += n
end #=> 10
```

```rb
numbers = [ 1, 2, 3, 4 ]
sum = 0
numbers.each { |n| sum += n } #=> 10
```

以上の例においては、それぞれの要素が足し上げられて、  
`sum`という変数に代入されている。  

この操作を定義しているのが、ブロックに関する部分である。  
ブロックの範囲とは、`do |n|` 以降の部分である。  

ブロックの内部（つまり、`sum += n`に関する部分）では、  
自由にRubyのコードが書けます。  

### 配列の要素を削除する条件を指定する

ブロックを使うと、配列の中の奇数だけを削除することもできる。  

```rb
a =[ 1, 2, 3 ]
a.delete_if do |n|
  n.odd?
end
a #=> [2]
```

### 注意点

- ブロック内部の変数のスコープは、あくまでブロック内
- ブロック引数（多くの場合、|n|）について
  - ブロック内部で使わない場合、省略できる
  - ブロック内部
- do ...endは、{} で書き換えられる
  - 先ほどの事例は以下のとおり書き換え可能

```rb
a =[ 1, 2, 3 ]
a.delete_if { |n| n.odd? }
```

## ブロックを使う配列のメソッド

### map/collect

mapメソッドは、各要素に対してブロックを評価した結果を「新しい配列」にして返す。  

```rb
numbers = [ 1, 2, 3, 4, 5 ]
new_numbers = []
# n * 10 の処理を行い、new_numbers配列に格納していく
numbers.each { |n| new_numbers << n * 10 }
new_numbers #=> [10, 20, 30, 40 ,50]
```

新しい配列を宣言しなくとも、戻り値を利用して以下のように書ける。  

```rb
numbers = [ 1, 2, 3, 4, 5 ]
# new_numbersを宣言し、そこに戻り値として生成された配列を格納する
new_numbers = numbers.each {|n| n *10 }
new_numbers  #=> [10, 20, 30, 40 ,50]
```

### select/find_all/reject

selectメソッド（エイリアスメソッドはfind_all)は各要素に対してブロックを評価し、  
「その戻り値が真の要素を集めた配列を返す」メソッドである。  

```rb
numbers = [ 1, 2, 3, 4, 5 ]
new_numbers = numbers.select {|n| n.even? }
new_numbers  #=> [2, 4]
```

rejectメソッドを使うと、真ではなく、その戻り値が「偽」の要素を集めた配列を返す。  

```rb
numbers = [ 1, 2, 3, 4, 5 ]
new_numbers = numbers.reject {|n| n.even? }
new_numbers  #=> [ 1, 3, 5 ]
```

### find/detectメソッド

ブロックの戻り値が真になった最初の要素を返す。  
配列ではないことに注意。

```rb
numbers = [ 1, 2, 3, 4, 5 ]
new_numbers = numbers.find {|n| n.even? }
new_numbers  #=> 2
```

### inject/reduceメソッド

たたみ込み演算を行うメソッドです。  

```rb
numbers = [ 1, 2, 3, 4 ]
sum = numbers.inject(0) {|result, n| result + n }
sum  #=> 10
```

ここで何が起きているのかというと以下のとおり。  

```
result = 0, n = 1
result + n = 1 # これをたたみ込む

result = 1 , n = 2
result + n = 3 # これをたたみ込む

result = 3, n = 3
result + n = 6 # これをたたみ込む

result = 6, n = 4
result + n = 10 # これをたたみ込む
```

### & と シンボルを使って簡潔に書く

ブロックを使うメソッドは条件によって簡潔に書くことができる。  

```rb
# 書き換え前
[ 1, 2, 3, 4, 5 ].select { |n| n.odd? } #=> [ 1, 3, 5 ]

# 書き換え後
# ここでは &:odd?という引数を渡している
[ 1, 2, 3, 4, 5 ].select (&:odd?) #=> [ 1, 3, 5 ]
```

使える条件は以下のとおり。

1. ブロック引数が１個だけ
2. ブロックの中で呼び出すメソッドには引数がない
3. ブロックの中では、ブロック引数に対してメソッドを呼び出す以外の処理がない

## 範囲

値の範囲を示すオブジェクトがある。  
これらはRangeクラスに属している。  

```rb
1..5
1...5
'a'..'e'
```

`include?`メソッドを使うと、引数の値に含まれるか判定できる。  

```rb
range = 1..5
range.include?(3) #=> true
range.include?(4.9) #=> true
range.include?(5) #=> true
```

なお、`..`と`...`には違いがある。  
`...`だと末尾が含まれない。

```rb
range = 1...5
range.include?(5) #=> false
```

### 配列や文字列の一部を抜き出す

```rb
a = [ 1, 2, 3, 4, 5]

# １〜３番目の要素を取得
a[1..3] = [ 2, 3, 4 ]
```

### 値が連続する配列を作成

`to_a`メソッドを使って、配列に変換する。

```rb
(1..5)to_a = [ 1, 2, 3, 4, 5 ]
```

splat展開という書き方もある。  

```rb
[*1..5] #=> [ 1, 2, 3, 4, 5 ]
```

### 繰り返し処理を行う

範囲オブジェクトに対して、直接`each`メソッドを呼び出すことができる。  

```rb
sum = 0
sum = (1..4).each { |n| sum += n }
sum #=> 10
```

stepメソッドを使うと、値を増やす間隔を指定できる。  

```rb
numbers = []
# 1から10まで2つ飛ばしで繰り返し処理を行う
(1..10).step(2) { |n| numbers << n}
numbers #=> [ 1, 3, 5, 7, 9 ]
```
