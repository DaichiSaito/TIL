# Chapter04 配列や繰り返しを処理する

## 配列

### 配列の概要

- []で表される
- 要素にはindexがある
  - 0からスタートする
- lengthもしくはsizeメソッドで要素数を取得できる
  - 繰り返し処理をする場合によく使うイメージ

```rb
a = [ 10, 20, 30 ]

# 0番目の要素を取得（0からスタート）
a[0] #=> 10

a.length #=> 3
```

### 要素の変更、追加、削除

要素は変更できる。  

```rb
a =[ 10, 20, 30]

a[1] = 77
a #=> [ 77, 20, 30 ]
```

要素は追加できる。  
間がある場合、`nil`で埋められる。  

```rb
a =[ 10, 20, 30]

a[5] = 77
a #=> [ 10, 20, 30, nil, 77 ]
```

配列の最後に要素を追加したい場合、以下のとおり書くことができる。  

```rb
a = [ 10, 20, 30 ]

a << 77
a #=> [ 10, 20, 30 ,77 ]
```

配列内の特定の位置にある要素を削除したい場合、delete_atメソッドを使う。  

```rb
a = [ 10, 20, 30 ]

# ２番目の要素を削除し、戻り値が削除した要素になる
a.delete_at(1) #=> 20
a #=> [ 10,30 ]

# 存在しない添え字を指定するとnilになる
a.delete_at(100) #=> nil
```

### 配列を使った多重代入

配列を使った多重代入について。  

```rb
a, b = [ 1, 2 ]
a #=> 1
b #=> 2

c, d = [10]
c #=> 10
d #=> nil

e = [ 100, 200 ]
e #=> 100
```

## ブロック

### Rubyの繰り返し処理

Rubyでは`for`を使うことが少ない。  
`each`を配列自体に使うことが多い。  

`each`メソッドにより、配列の要素を最初から最後まで取り出している。  

```rb
numbers = [ 1, 2, 3, 4 ]
sum = 0
numbers.each do |n|
  sum += n
end #=> 10
```

```rb
numbers = [ 1, 2, 3, 4 ]
sum = 0
numbers.each { |n| sum += n } #=> 10
```

以上の例においては、それぞれの要素が足し上げられて、  
`sum`という変数に代入されている。  

この操作を定義しているのが、ブロックに関する部分である。  
ブロックの範囲とは、`do |n|` 以降の部分である。  

ブロックの内部（つまり、`sum += n`に関する部分）では、  
自由にRubyのコードが書けます。  

### 配列の要素を削除する条件を指定する

ブロックを使うと、配列の中の奇数だけを削除することもできる。  

```rb
a =[ 1, 2, 3 ]
a.delete_if do |n|
  n.odd?
end
a #=> [2]
```

### 注意点

- ブロック内部の変数のスコープは、あくまでブロック内
- ブロック引数（多くの場合、|n|）について
  - ブロック内部で使わない場合、省略できる
  - ブロック内部
- do ...endは、{} で書き換えられる
  - 先ほどの事例は以下のとおり書き換え可能

```rb
a =[ 1, 2, 3 ]
a.delete_if { |n| n.odd? }
```

## ブロックを使う配列のメソッド

### map/collect

mapメソッドは、各要素に対してブロックを評価した結果を「新しい配列」にして返す。  
新しい配列を宣言しなくとも、戻り値を利用して以下のように書ける。  

```rb
# eachメソッド

numbers = [ 1, 2, 3, 4, 5 ]
new_numbers = []
# n * 10 の処理を行い、new_numbers配列に格納していく
numbers.each { |n| new_numbers << n * 10 }
new_numbers #=> [10, 20, 30, 40 ,50]
```

```rb
# mapメソッドによるリファクタリング

numbers = [ 1, 2, 3, 4, 5 ]
# new_numbersを宣言し、そこに戻り値として生成された配列を格納する
new_numbers = numbers.map {|n| n *10 }
new_numbers  #=> [10, 20, 30, 40 ,50]
```

### select/find_all/reject

selectメソッド（エイリアスメソッドはfind_all)は各要素に対してブロックを評価し、  
「その戻り値が真の要素を集めた配列を返す」メソッドである。  

```rb
numbers = [ 1, 2, 3, 4, 5 ]
new_numbers = numbers.select {|n| n.even? }
new_numbers  #=> [2, 4]
```

rejectメソッドを使うと、真ではなく、その戻り値が「偽」の要素を集めた配列を返す。  

```rb
numbers = [ 1, 2, 3, 4, 5 ]
new_numbers = numbers.reject {|n| n.even? }
new_numbers  #=> [ 1, 3, 5 ]
```

### find/detectメソッド

ブロックの戻り値が真になった最初の要素を返す。  
配列ではないことに注意。

```rb
numbers = [ 1, 2, 3, 4, 5 ]
new_numbers = numbers.find {|n| n.even? }
new_numbers  #=> 2
```

### inject/reduceメソッド

たたみ込み演算を行うメソッドです。  

```rb
numbers = [ 1, 2, 3, 4 ]
sum = numbers.inject(0) {|result, n| result + n }
sum  #=> 10
```

ここで何が起きているのかというと以下のとおり。  

```
result = 0, n = 1
result + n = 1 # これをたたみ込む

result = 1 , n = 2
result + n = 3 # これをたたみ込む

result = 3, n = 3
result + n = 6 # これをたたみ込む

result = 6, n = 4
result + n = 10 # これをたたみ込む
```

### & と シンボルを使って簡潔に書く

ブロックを使うメソッドは条件によって簡潔に書くことができる。  

```rb
# 書き換え前
[ 1, 2, 3, 4, 5 ].select { |n| n.odd? } #=> [ 1, 3, 5 ]

# 書き換え後
# ここでは &:odd?という引数を渡している
[ 1, 2, 3, 4, 5 ].select (&:odd?) #=> [ 1, 3, 5 ]
```

使える条件は以下のとおり。

1. ブロック引数が１個だけ
2. ブロックの中で呼び出すメソッドには引数がない
3. ブロックの中では、ブロック引数に対してメソッドを呼び出す以外の処理がない

## 範囲

値の範囲を示すオブジェクトがある。  
これらはRangeクラスに属している。  

```rb
1..5
1...5
'a'..'e'
```

`include?`メソッドを使うと、引数の値に含まれるか判定できる。  

```rb
range = 1..5
range.include?(3) #=> true
range.include?(4.9) #=> true
range.include?(5) #=> true
```

なお、`..`と`...`には違いがある。  
`...`だと末尾が含まれない。

```rb
range = 1...5
range.include?(5) #=> false
```

### 配列や文字列の一部を抜き出す

```rb
a = [ 1, 2, 3, 4, 5]

# １〜３番目の要素を取得
a[1..3] = [ 2, 3, 4 ]
```

### 値が連続する配列を作成

`to_a`メソッドを使って、配列に変換する。

```rb
(1..5)to_a = [ 1, 2, 3, 4, 5 ]
```

splat展開という書き方もある。  

```rb
[*1..5] #=> [ 1, 2, 3, 4, 5 ]
```

### 繰り返し処理を行う

範囲オブジェクトに対して、直接`each`メソッドを呼び出すことができる。  

```rb
sum = 0
sum = (1..4).each { |n| sum += n }
sum #=> 10
```

stepメソッドを使うと、値を増やす間隔を指定できる。  

```rb
numbers = []
# 1から10まで2つ飛ばしで繰り返し処理を行う
(1..10).step(2) { |n| numbers << n}
numbers #=> [ 1, 3, 5, 7, 9 ]
```

## 例題：RGB変換プログラムを作成する

`rgb_test.rb`と`rgb.rb`を作成し、実践してみた。  
リファクタリング後のコードがヤバイ。。。  

## 配列についてもっと詳しく

### さまざまな要素の取得方法

添え字を２つ使うと、添え字の位置と取得する長さを指定できる。  
この場合、配列が返ってくる。  

```rb
# a の１番目（つまり２番目）の要素から、要素を3つ取得する

a = [1, 2, 3, 4, 5]
a[1, 3] #=> [2, 3, 4]
```

values_atメソッドを使うと、取得したい要素を指定できる。  

```rb
# a の０番目、２番目、４番目の要素を取得する

a = [1, 2, 3, 4, 5]
a.values_at(0, 2, 4) #=> [1, 3, 5]
```

「配列の長さ - 1 」を指定すれば、最後の要素を取得できる。  
単純に「-1」と書いてもよいし、lastメソッドを使ってもよい。  

```rb
# a の最後の要素を取得する

# こうやって当然書ける
a = [1, 2, 3, 4, 5]
a[a.length - 1] #=> 5

# 楽に書ける
a[-1] #=> 5

# 最後から２番目の要素を取得
a[-2] #=> 4

# lastメソッドを使ってもよい
a.last #=> 5

# firstメソッドもある
a.first #=> 0
```

### さまざまな要素の変更方法

値を変更する場合、以下のとおり。

```rb
a = [1, 2, 3]
a[0] = 100
a #=> [100, 2, 3]

a[-1] = 300
a #=> [100, 2 , 300]
```

開始位置と長さを指定して、要素を置き換えることもできる。  

```rb
a = [1, 2, 3, 4, 5]
# 2つ目から３要素分を100で置き換える
a[1, 3] = 100
a #=> [1, 100, 5]

# 2 ~ 4 が 100 に置き換わった
```

配列に要素を加えていく場合、<< を使うかと思うが、
`push`メソッドを使うこともできる。  

```rb
a = []
a.push(1) #=> [1]
a.push(2, 3) #=> [1, 2, 3]

b = []
b << 1 #=> [1]
b << [2, 3] #=> [1, [2, 3]]
# 複数の要素を一度に追加するのは無理？なので、flattenメソッドを使う
b.flatten #=> [1, 2, 3]
```

[Rubyで複数の配列を１つの配列に結合するために色々やってみた \- Qiita](https://qiita.com/na1412/items/65f883896c85011d6509)  

指定した値に一致する要素を削除したい場合、`delete`メソッドを使う。  

```rb
a = [1, 2, 3, 1, 2, 3]
a.delete(2) #=> 2
a #=> [1, 3, 1, 3]

# 存在しない値を削除しようとすると、戻り値はnilになる
a.delete(5) #=> nil
a #=> [1, 3, 1, 3]
```

### 配列の連結

2つの配列を連結したい場合は、concatメソッドか、`+` 演算子を使います。  
`concat`は元のオブジェクトを変更する破壊的メソッドであり、  
`+` 演算子は元のオブジェクトを変更しない非破壊的なメソッドである。  

```rb
# 破壊的

a = [1]
b = [2, 3]
a.concat(b) #=> [1, 2, 3]
a #=> [1, 2, 3]
b #=> [2, 3]
```

```rb
# 非破壊的

a = [1]
b = [2, 3]
a + b #=> [1, 2, 3]
a #=> [1]
```

### 配列の和集合、差集合、積集合

そもそも和集合・差集合・積集合って。。。

```rb
# 和集合だと重複を取り除いて、配列を足し上げてくれる
# bの中から、重複していない[2]のみを足し上げている

a = [1, 4, 3] 
b = [4, 3, 2]
a | b #=> [1, 4, 3, 2]
```

```rb
# 差集合だと重複している部分のみを差し引く
# 共通している要素である 4 と 3 を a から差し引く

a = [1, 4, 3]
b = [4, 3, 2]
a - b #=> [1]
```

```rb
# 積集合は、重複している部分を求めてくれる
# a, b の共通部分を取り出すイメージ
# ちなみに、集合演算をやる場合、Setクラスにするとよいらしい

a = [1, 4, 3]
b = [4, 3, 2]
a & b #=> [4, 3]
```

### 多重代入で残りの全要素を配列として受け取る

右辺の個数が多い場合、はみ出した値が切り捨てられる。
この場合も、それぞれの受け皿が１つしかないので、300は切り捨てられる。  

```rb
e, f = 100, 200, 300, 400
e #=> 100
f #=> 200
```

ただ、*を使うと、残りの全要素を配列として`f`に入れ込める。  

```rb
e, *f = 100, 200, 300, 400
e #=> 100
f #=> [200, 300, 400]
```

### 1つの配列を複数の引数（要素）として展開する

日本語が分かりづらいが、要は引数を`[]`がついた状態ではなく、  
その中身を打ち込みたい時はどうするのかという話。  

```rb
a = [1]
b = [2, 3]
a.push(b) #=> [1, [2, 3]]
```

けど、配列の中に配列は困るという場合、こうするとよい。  

```rb
a = [1]
b = [2, 3]
a.push(*b) #=> [1, 2, 3]
```

### メソッドの引数を制限しない

先ほどのアスタリスクを使うと、以下のとおり引数の個数を指定しないことができる。  
引数の数は、１個でも１０個でも問題なく出力できる。  

```rb
def greetings(*names)
  "#{names.join('と')}、こんにちは"
end

greetings("田中さん", "緒方さん", "三宅さん")
#=> 田中さんと緒方さんと三宅さん、こんにちは
```

### ＊で配列同士を非破壊的に連結する

`[]`の中に*付きで別の配列を置くと、その要素を間に挟むことができる。  

```rb
a =[1, 2, 3]
[-1, 0, *a, 4, 5]
#=> [-1, 0, 1, 2, 3, 4, 5]
```

### %記法で文字列の配列を簡潔に作る

配列は[]を使って作成することが多いが、文字列は`%w`もしくは`%W`を使って作成することができる。  
これを活用すると、文字列の配列ではクオートで囲む必要がなくなる。  

なお、`()`で囲っているが、記号であればなんでもよい。  

```rb
#=> before
["田中さん", "緒方さん", "三宅さん"]  

#=> after
%w(田中さん 緒方さん 三宅さん)
```

ちなみに、こういうルーティングの書き方をしているのをみた。  

```rb
resources :users, only: %i[new create]
  #=> resources :users, only: %i[:new, :create]
```

値にスペースを含めたいばいは、バックスラッシュを使う。  

```rb
%w(big\ apple small\ orange rotten\ lemon)
  #=>  ["big apple", "small orange", "rotten lemon"]
```

### 文字列を配列に分解する

使いどころがなさそうだけど、文字ごとに分解したり、区切り文字ごとに分解できる。  

### 配列に初期値を設定する

`Array.new`を使うこともできる。
事前に要素の数を指定できる。  

```rb
a = Array.new(5)
a #=> [nil, nil, nil, nil, nil]
```

ブロックを使って初期値を設定することができる。  
以下の例では0が代入されて、その余りに１を足したものが次々と出力されている。  

```rb
a = Array.new(10){ |n| n % 3 + 1 }
a #=> [1, 2, 3, 1, 2, 3, 1, 2, 3, 1]
```

### 配列に初期値を設定する場合の注意点

さらっと読んだ。  
配列で第二引数を使う場合は要注意。  

```rb

# 全部変わっちゃう！！！

a = Array.new(3, 'default')
a #=> ["default", "default", "default"]
a[0].upcase!
a #=> ["DEFAULT", "DEFAULT", "DEFAULT"]

# 一部のみしか変わらない！！！

a = Array.new(3){'default'}
a #=> ["default", "default", "default"]
a[0].upcase!
=> ["DEFAULT", "default", "default"]
```

## ブロックについてもっと詳しく

### 添え字付きの繰り返し処理（each＿with＿index)

要素の添え字を追加できる。  

```rb
fruits = ['apple', 'orange', 'melon']
fruits.each { |fruit| puts "#{fruit}"}
#=> apple
#=> orange
#=> melon

# 第二引数に要素の添え字を添付できる
fruits.each_with_index { |fruit, i| puts "#{i}: #{fruit}" }
#=> 0: apple
#=> 1: orange
#=> 2: melon
```

### mapメソッドとwith_indexを組み合わせる

繰り返し処理をしつつ、添え字も同時に取得できる。  

```rb
fruits = ['apple', 'orange', 'melon']
fruits.map.with_index { |fruit, i | "#{i}: #{fruit}" }
#=> ["0: apple", "1: orange", "2: melon"]
```


